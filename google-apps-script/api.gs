// ============================================
// Google Apps Script API - Auto Generated
// Generated by sheet-schema gen-gas
// ============================================

// === Configuration ===
const SPREADSHEET_ID = '17bGDqeGN9ycBSWTtnQJWRdlqg7GVx0QQh_Z6FWbJhPE';

const TABLES = {
  "member": {
    "sheetName": "member",
    "columns": [
      "id",
      "full_name",
      "gender",
      "birthday",
      "phone",
      "status",
      "account_number",
      "admin",
      "joined_at",
      "created_at",
      "updated_at",
      "note"
    ],
    "refs": []
  },
  "competition": {
    "sheetName": "competition",
    "columns": [
      "id",
      "competition_type",
      "competition_name",
      "competition_class",
      "distance_km",
      "pb_key",
      "competition_date",
      "created_at",
      "updated_at"
    ],
    "refs": []
  },
  "title_definition": {
    "sheetName": "title_definition",
    "columns": [
      "id",
      "title_group",
      "title_name",
      "criteria_text",
      "criteria_type",
      "priority"
    ],
    "refs": []
  },
  "comp_application": {
    "sheetName": "comp_application",
    "columns": [
      "id",
      "member_id",
      "full_name",
      "competition_id",
      "competition_name",
      "competition_class",
      "status",
      "pledge",
      "created_at",
      "updated_at"
    ],
    "refs": [
      {
        "column": "member_id",
        "table": "member",
        "field": "id",
        "expandKey": "member",
        "onDelete": "restrict"
      },
      {
        "column": "competition_id",
        "table": "competition",
        "field": "id",
        "expandKey": "competition",
        "onDelete": "restrict"
      }
    ]
  },
  "activity_log": {
    "sheetName": "activity_log",
    "columns": [
      "id",
      "member_id",
      "full_name",
      "activity_date",
      "activity_type",
      "distance_km",
      "duration_sec",
      "duration_hhmmss",
      "event_id",
      "event_name",
      "competition_id",
      "competition_name",
      "competition_class",
      "elevation_gain_m",
      "created_at",
      "updated_at"
    ],
    "refs": [
      {
        "column": "member_id",
        "table": "member",
        "field": "id",
        "expandKey": "member",
        "onDelete": "restrict"
      },
      {
        "column": "competition_id",
        "table": "competition",
        "field": "id",
        "expandKey": "competition",
        "onDelete": "restrict"
      }
    ]
  },
  "personal_best": {
    "sheetName": "personal_best",
    "columns": [
      "id",
      "member_id",
      "full_name",
      "pb_key",
      "best_time_sec",
      "best_time_hhmmss",
      "best_date",
      "source_type",
      "source_ref_id",
      "competition_name",
      "updated_at"
    ],
    "refs": [
      {
        "column": "member_id",
        "table": "member",
        "field": "id",
        "expandKey": "member",
        "onDelete": "restrict"
      }
    ]
  },
  "member_title": {
    "sheetName": "member_title",
    "columns": [
      "id",
      "member_id",
      "full_name",
      "title_group",
      "title_name",
      "assigned_by",
      "source_ref_id",
      "assigned_at"
    ],
    "refs": [
      {
        "column": "member_id",
        "table": "member",
        "field": "id",
        "expandKey": "member",
        "onDelete": "restrict"
      }
    ]
  },
  "member_utmb": {
    "sheetName": "member_utmb",
    "columns": [
      "member_id",
      "utmb_key"
    ],
    "refs": [
      {
        "column": "member_id",
        "table": "member",
        "field": "id",
        "expandKey": "member",
        "onDelete": "cascade"
      }
    ]
  }
};

// === HTTP Handlers ===

function doGet(e) {
  return handleRequest(e, 'GET');
}

function doPost(e) {
  return handleRequest(e, 'POST');
}

function handleRequest(e, defaultMethod) {
  try {
    const params = e.parameter || {};
    const method = (params._method || defaultMethod).toUpperCase();
    const tableName = params.table;
    const id = params.id;

    if (!tableName) {
      return jsonResponse({ error: 'Missing table parameter' }, 400);
    }

    if (!TABLES[tableName]) {
      return jsonResponse({ error: 'Table not found: ' + tableName }, 404);
    }

    let result;

    switch (method) {
      case 'GET':
        if (id) {
          result = getById(tableName, id, params);
        } else {
          result = getAll(tableName, params);
        }
        break;

      case 'POST':
        const createData = JSON.parse(e.postData?.contents || '{}');
        result = create(tableName, createData);
        break;

      case 'PUT':
        if (!id) {
          return jsonResponse({ error: 'Missing id for PUT' }, 400);
        }
        const putData = JSON.parse(e.postData?.contents || '{}');
        result = update(tableName, id, putData, false);
        break;

      case 'PATCH':
        if (!id) {
          return jsonResponse({ error: 'Missing id for PATCH' }, 400);
        }
        const patchData = JSON.parse(e.postData?.contents || '{}');
        result = update(tableName, id, patchData, true);
        break;

      case 'DELETE':
        if (!id) {
          return jsonResponse({ error: 'Missing id for DELETE' }, 400);
        }
        result = remove(tableName, id);
        break;

      default:
        return jsonResponse({ error: 'Unsupported method: ' + method }, 405);
    }

    return jsonResponse(result);
  } catch (error) {
    return jsonResponse({ error: error.message || String(error) }, 500);
  }
}

function jsonResponse(data, status = 200) {
  const output = ContentService.createTextOutput(JSON.stringify(data));
  output.setMimeType(ContentService.MimeType.JSON);
  return output;
}

// === CRUD Operations ===

function getAll(tableName, params) {
  const sheet = getSheet(tableName);
  const data = getSheetData(sheet);

  let result = data;

  // Apply filters
  const filterParams = {};
  for (const key in params) {
    if (!['table', 'id', 'sort', 'expand', '_method'].includes(key)) {
      filterParams[key] = params[key];
    }
  }
  if (Object.keys(filterParams).length > 0) {
    result = applyFilter(result, filterParams);
  }

  // Apply sort
  if (params.sort) {
    result = applySort(result, params.sort);
  }

  // Apply expand
  if (params.expand) {
    const expandKeys = params.expand.split(',').map(k => k.trim());
    result = result.map(row => expandRelations(tableName, row, expandKeys));
  }

  return { data: result, count: result.length };
}

function getById(tableName, id, params) {
  const sheet = getSheet(tableName);
  const data = getSheetData(sheet);

  // member_utmb는 id 컬럼이 없고 member_id가 키
  const idField = (tableName === 'member_utmb') ? 'member_id' : 'id';
  let row = data.find(r => String(r[idField]) === String(id));

  if (!row) {
    throw new Error('Not found: ' + id);
  }

  // Apply expand
  if (params.expand) {
    const expandKeys = params.expand.split(',').map(k => k.trim());
    row = expandRelations(tableName, row, expandKeys);
  }

  return { data: row };
}

function create(tableName, data) {
  // Validate foreign keys
  validateForeignKeys(tableName, data);

  const sheet = getSheet(tableName);
  const headers = getHeaders(sheet);

  // member_utmb는 id 컬럼이 없음
  if (tableName !== 'member_utmb') {
    // Generate ID if not provided
    if (!data.id) {
      data.id = Utilities.getUuid();
    }

    // Add created_at if column exists
    if (headers.includes('created_at') && !data.created_at) {
      data.created_at = new Date().toISOString();
    }
  }

  // Build row values
  const rowValues = headers.map(h => {
    const val = data[h];
    if (val === undefined || val === null) return '';
    if (typeof val === 'object') return JSON.stringify(val);
    return val;
  });

  sheet.appendRow(rowValues);

  return { data: data, message: 'Created successfully' };
}

function update(tableName, id, data, partial = false) {
  // Validate foreign keys
  validateForeignKeys(tableName, data);

  const sheet = getSheet(tableName);
  const headers = getHeaders(sheet);
  const rowIndex = findRowIndexById(sheet, id, tableName);

  if (rowIndex === -1) {
    throw new Error('Not found: ' + id);
  }

  const existingRow = sheet.getRange(rowIndex, 1, 1, headers.length).getValues()[0];
  const existingData = parseRow(headers, existingRow);

  // Merge data
  let newData;
  if (partial) {
    newData = { ...existingData, ...data };
  } else {
    if (tableName === 'member_utmb') {
      newData = { ...data };
    } else {
      newData = { id, ...data };
    }
  }

  // Add updated_at if column exists
  if (headers.includes('updated_at')) {
    newData.updated_at = new Date().toISOString();
  }

  // Build row values
  const rowValues = headers.map(h => {
    const val = newData[h];
    if (val === undefined || val === null) return '';
    if (typeof val === 'object') return JSON.stringify(val);
    return val;
  });

  sheet.getRange(rowIndex, 1, 1, headers.length).setValues([rowValues]);

  return { data: newData, message: 'Updated successfully' };
}

function remove(tableName, id) {
  const sheet = getSheet(tableName);
  const rowIndex = findRowIndexById(sheet, id, tableName);

  if (rowIndex === -1) {
    throw new Error('Not found: ' + id);
  }

  // Handle cascading deletes
  cascadeDelete(tableName, id);

  // Delete the row
  sheet.deleteRow(rowIndex);

  return { message: 'Deleted successfully', id };
}

// === Foreign Key Validation ===

function validateForeignKeys(tableName, data) {
  const tableInfo = TABLES[tableName];
  if (!tableInfo || !tableInfo.refs) return;

  for (const ref of tableInfo.refs) {
    const value = data[ref.column];
    if (value === undefined || value === null || value === '') continue;

    // Handle array values
    const values = Array.isArray(value) ? value : [value];

    for (const v of values) {
      if (!v) continue;

      const refSheet = getSheet(ref.table);
      const refData = getSheetData(refSheet);
      const exists = refData.some(row => String(row[ref.field]) === String(v));

      if (!exists) {
        throw new Error(
          'Foreign key violation: ' + ref.column + ' references non-existent ' +
          ref.table + '.' + ref.field + ' = ' + v
        );
      }
    }
  }
}

// === Cascading Delete ===

function cascadeDelete(tableName, id) {
  // Find all tables that reference this table
  for (const otherTableName in TABLES) {
    const otherTable = TABLES[otherTableName];
    if (!otherTable.refs) continue;

    for (const ref of otherTable.refs) {
      if (ref.table !== tableName) continue;

      const otherSheet = getSheet(otherTableName);
      const otherData = getSheetData(otherSheet);
      const headers = getHeaders(otherSheet);

      // Find rows that reference the deleted id
      for (let i = otherData.length - 1; i >= 0; i--) {
        const row = otherData[i];
        let refValue = row[ref.column];

        // Handle array values
        const refValues = Array.isArray(refValue) ? refValue : [refValue];
        const matches = refValues.some(v => String(v) === String(id));

        if (!matches) continue;

        const idField = (otherTableName === 'member_utmb') ? 'member_id' : 'id';
        const rowIndex = findRowIndexById(otherSheet, row[idField], otherTableName);

        switch (ref.onDelete) {
          case 'cascade':
            // Recursively delete
            if (idField === 'id') {
              cascadeDelete(otherTableName, row.id);
            }
            otherSheet.deleteRow(rowIndex);
            break;

          case 'restrict':
            throw new Error(
              'Cannot delete: ' + tableName + '.' + id +
              ' is referenced by ' + otherTableName + '.' + row[idField]
            );

          case 'set_null':
            // Set the reference column to null
            const colIndex = headers.indexOf(ref.column) + 1;
            if (colIndex > 0) {
              otherSheet.getRange(rowIndex, colIndex).setValue('');
            }
            break;
        }
      }
    }
  }
}

// === Expand Relations ===

function expandRelations(tableName, row, expandKeys) {
  const tableInfo = TABLES[tableName];
  if (!tableInfo || !tableInfo.refs) return row;

  const expanded = { ...row };

  for (const ref of tableInfo.refs) {
    const expandKey = ref.expandKey || ref.column.replace(/_id$/, '');

    if (!expandKeys.includes(expandKey) && !expandKeys.includes(ref.column)) {
      continue;
    }

    const refValue = row[ref.column];
    if (!refValue) continue;

    try {
      const refSheet = getSheet(ref.table);
      const refData = getSheetData(refSheet);

      // Handle array values
      if (Array.isArray(refValue)) {
        expanded[expandKey] = refValue
          .map(v => refData.find(r => String(r[ref.field]) === String(v)))
          .filter(Boolean);
      } else {
        const found = refData.find(r => String(r[ref.field]) === String(refValue));
        if (found) {
          expanded[expandKey] = found;
        }
      }
    } catch (e) {
      // Ignore expand errors
    }
  }

  return expanded;
}

// === Sort & Filter ===

function applySort(data, sortParam) {
  const sorts = sortParam.split(',').map(s => s.trim());

  return [...data].sort((a, b) => {
    for (const sort of sorts) {
      const desc = sort.startsWith('-');
      const field = desc ? sort.slice(1) : sort;

      let aVal = a[field];
      let bVal = b[field];

      // Handle null/undefined
      if (aVal == null && bVal == null) continue;
      if (aVal == null) return desc ? -1 : 1;
      if (bVal == null) return desc ? 1 : -1;

      // Compare
      let cmp = 0;
      if (typeof aVal === 'number' && typeof bVal === 'number') {
        cmp = aVal - bVal;
      } else {
        cmp = String(aVal).localeCompare(String(bVal));
      }

      if (cmp !== 0) {
        return desc ? -cmp : cmp;
      }
    }
    return 0;
  });
}

function applyFilter(data, filterParams) {
  return data.filter(row => {
    for (const key in filterParams) {
      const value = filterParams[key];

      // Parse operator from key (e.g., price__gte)
      const parts = key.split('__');
      const field = parts[0];
      const op = parts[1] || 'eq';

      const rowValue = row[field];

      switch (op) {
        case 'eq':
          if (String(rowValue) !== String(value)) return false;
          break;
        case 'ne':
          if (String(rowValue) === String(value)) return false;
          break;
        case 'gt':
          if (!(Number(rowValue) > Number(value))) return false;
          break;
        case 'gte':
          if (!(Number(rowValue) >= Number(value))) return false;
          break;
        case 'lt':
          if (!(Number(rowValue) < Number(value))) return false;
          break;
        case 'lte':
          if (!(Number(rowValue) <= Number(value))) return false;
          break;
        case 'contains':
          if (!String(rowValue).includes(String(value))) return false;
          break;
        case 'startswith':
          if (!String(rowValue).startsWith(String(value))) return false;
          break;
        case 'endswith':
          if (!String(rowValue).endsWith(String(value))) return false;
          break;
      }
    }
    return true;
  });
}

// === Utility Functions ===

function getSheet(tableName) {
  const tableInfo = TABLES[tableName];
  if (!tableInfo) {
    throw new Error('Unknown table: ' + tableName);
  }

  const ss = SpreadsheetApp.openById(SPREADSHEET_ID);
  const sheet = ss.getSheetByName(tableInfo.sheetName);

  if (!sheet) {
    throw new Error('Sheet not found: ' + tableInfo.sheetName);
  }

  return sheet;
}

function getHeaders(sheet) {
  // Row 1 is description, row 2 is the actual header
  const headerRow = sheet.getRange(2, 1, 1, sheet.getLastColumn()).getValues()[0];
  return headerRow.map(h => {
    // Parse header to get column name (remove type hints)
    const str = String(h).trim();
    const colonIndex = str.indexOf(':');
    let name = colonIndex >= 0 ? str.slice(0, colonIndex).trim() : str;
    // Remove required marker
    if (name.endsWith('*')) {
      name = name.slice(0, -1).trim();
    }
    return name;
  });
}

function getSheetData(sheet) {
  const headers = getHeaders(sheet);
  const lastRow = sheet.getLastRow();

  // Row 1 is description, row 2 is header, row 3+ is data
  if (lastRow < 3) return [];

  const dataRange = sheet.getRange(3, 1, lastRow - 2, headers.length);
  const values = dataRange.getValues();

  // member_utmb는 id 컬럼이 없으므로 member_id가 있는 행만 필터링
  return values.map(row => parseRow(headers, row)).filter(row => {
    if (sheet.getName() === 'member_utmb') {
      return row.member_id;
    }
    return row.id;
  });
}

function parseRow(headers, values) {
  const obj = {};
  for (let i = 0; i < headers.length; i++) {
    const header = headers[i];
    let value = values[i];

    // Parse JSON if it looks like JSON
    if (typeof value === 'string' && (value.startsWith('[') || value.startsWith('{'))) {
      try {
        value = JSON.parse(value);
      } catch (e) {
        // Keep as string
      }
    }

    // Handle empty strings
    if (value === '') {
      value = null;
    }

    obj[header] = value;
  }
  return obj;
}

function findRowIndexById(sheet, id, tableName) {
  const headers = getHeaders(sheet);

  // member_utmb는 member_id가 키
  const idField = (tableName === 'member_utmb') ? 'member_id' : 'id';
  const idColIndex = headers.indexOf(idField);

  if (idColIndex === -1) {
    throw new Error('Table has no ' + idField + ' column');
  }

  const lastRow = sheet.getLastRow();
  if (lastRow < 3) return -1;

  const idCol = sheet.getRange(3, idColIndex + 1, lastRow - 2, 1).getValues();

  for (let i = 0; i < idCol.length; i++) {
    if (String(idCol[i][0]) === String(id)) {
      return i + 3; // +3 for description row, header row, and 0-index
    }
  }

  return -1;
}
